{"version":3,"sources":["webpack:///assets/js/wp-taxonomy-import.min.js","webpack:///webpack/bootstrap 2b74047cce55f84c00a6","webpack:///./source/js/modules/no-jquery/index.js","webpack:///./source/js/modules/rest-api-request/index.js","webpack:///./source/js/wp-taxonomy-import.js","webpack:///./~/whatwg-fetch/fetch.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","ready","fn","document","attachEvent","readyState","addEventListener","Object","defineProperty","value","doFetch","request","fetch","then","response","contentType","headers","get","includes","TypeError","GET","url","data","arguments","length","undefined","nonce","query","keys","map","k","push","join","Headers","set","Request","credentials","method","POST","body","FormData","append","X-WP-Nonce","_noJquery","_restApiRequest","form","querySelector","importToField","importFromField","button","taxonomyBase","remoteRest","alert","termsByParent","termParentMap","window","URL","searchParams","page","totalPages","simplifyTerms","terms","parent","simpleTerms","forEach","term","name","slug","ajaxInsertTerms","ajaxurl","_nonce","taxonomyImport","ajaxNonce","action","taxonomy","JSON","stringify","json","parseInt","requestTerms","pageNum","toString","status","Array","isArray","console","log","self","normalizeName","String","test","toLowerCase","normalizeValue","iteratorFor","items","iterator","next","shift","done","support","iterable","Symbol","this","header","getOwnPropertyNames","consumed","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","onload","result","onerror","error","readBlobAsArrayBuffer","blob","FileReader","promise","readAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","buf","view","Uint8Array","chars","i","fromCharCode","bufferClone","slice","byteLength","buffer","Body","_initBody","_bodyInit","_bodyText","Blob","prototype","isPrototypeOf","_bodyBlob","formData","_bodyFormData","URLSearchParams","arrayBuffer","isDataView","_bodyArrayBuffer","ArrayBuffer","isArrayBufferView","Error","type","rejected","text","decode","parse","normalizeMethod","upcased","toUpperCase","methods","indexOf","input","options","mode","referrer","trim","split","bytes","replace","decodeURIComponent","parseHeaders","rawHeaders","line","parts","key","Response","bodyInit","ok","statusText","e","viewClasses","obj","DataView","isView","oldValue","has","hasOwnProperty","callback","thisArg","values","entries","clone","redirectStatuses","redirect","RangeError","location","init","xhr","XMLHttpRequest","getAllResponseHeaders","responseURL","responseText","ontimeout","open","withCredentials","responseType","setRequestHeader","send","polyfill"],"mappings":"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","file":"assets/js/wp-taxonomy-import.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(3);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ready = ready;\n\tfunction ready(fn) {\n\t    if (document.attachEvent ? document.readyState === 'complete' : document.readyState !== 'loading') {\n\t        fn();\n\t    } else {\n\t        document.addEventListener('DOMContentLoaded', fn);\n\t    }\n\t}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.GET = GET;\n\texports.POST = POST;\n\t\n\t__webpack_require__(4);\n\t\n\tfunction doFetch(request) {\n\t    // Make our fetch request.\n\t    return fetch(request).then(function (response) {\n\t        // Verify returned content type and setup response.\n\t        var contentType = response.headers.get('content-type');\n\t        if (contentType && contentType.includes('application/json')) {\n\t            return response;\n\t        }\n\t        // Invalid content received!\n\t        throw new TypeError('ERROR: Expected JSON response, received \\'' + contentType + '\\' instead!');\n\t    });\n\t}\n\t\n\tfunction GET(url) {\n\t    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t    var nonce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\t\n\t    var query = [];\n\t    Object.keys(data).map(function (k) {\n\t        return query.push(k + '=' + data[k]);\n\t    });\n\t\n\t    url += url.includes('?') ? '&' + query.join('&') : '?' + query.join('&');\n\t\n\t    var headers = new Headers();\n\t    if (nonce) {\n\t        headers.set('X-WP-Nonce', nonce);\n\t    }\n\t\n\t    var request = new Request(url, {\n\t        credentials: 'same-origin',\n\t        headers: headers,\n\t        method: 'GET'\n\t    });\n\t\n\t    return doFetch(request);\n\t}\n\t\n\tfunction POST(url) {\n\t    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t    var nonce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\t\n\t    // Set data as body content\n\t    var body = new FormData();\n\t    Object.keys(data).map(function (k) {\n\t        return body.append(k, data[k]);\n\t    });\n\t\n\t    // Create request\n\t    var request = new Request(url, {\n\t        credentials: 'same-origin',\n\t        body: body,\n\t        headers: new Headers({\n\t            'X-WP-Nonce': nonce\n\t        }),\n\t        method: 'POST'\n\t    });\n\t\n\t    return doFetch(request);\n\t}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _noJquery = __webpack_require__(1);\n\t\n\tvar _restApiRequest = __webpack_require__(2);\n\t\n\t(0, _noJquery.ready)(function () {\n\t\n\t    var form = document.querySelector('.taxonomy-import-form');\n\t\n\t    if (form) {\n\t        var importToField = form.querySelector('[name=\"_taxonomy_import_to\"]');\n\t        var importFromField = form.querySelector('[name=\"_taxonomy_import_rest_url\"]');\n\t        var button = form.querySelector('button');\n\t\n\t        button.addEventListener('click', function () {\n\t            var taxonomyBase = importToField.value;\n\t            var remoteRest = importFromField.value;\n\t            var method = form.querySelector('input[name=\"_taxonomy_import_use_ajax\"]').value === '' ? 'rest' : 'ajax';\n\t\n\t            if (!taxonomyBase || !remoteRest) {\n\t                alert('A required field was left empty!');\n\t                return;\n\t            }\n\t\n\t            var termsByParent = [];\n\t            var termParentMap = [];\n\t            var url = new window.URL(remoteRest);\n\t            url.searchParams.set('per_page', '100');\n\t\n\t            var page = 1;\n\t            var totalPages = 0;\n\t\n\t            var simplifyTerms = function simplifyTerms(terms, parent) {\n\t                var simpleTerms = [];\n\t                terms.forEach(function (term) {\n\t                    var data = {\n\t                        id: term.id,\n\t                        name: term.name,\n\t                        slug: term.slug,\n\t                        parent: 0\n\t                    };\n\t                    if (0 < parent && termParentMap[parent]) {\n\t                        data.parent = termParentMap[parent];\n\t                    }\n\t                    simpleTerms.push(data);\n\t                });\n\t\n\t                return simpleTerms;\n\t            };\n\t\n\t            var ajaxInsertTerms = function ajaxInsertTerms() {\n\t                var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\n\t                if (termsByParent[parent] && termsByParent[parent].length) {\n\t                    (0, _restApiRequest.POST)(window.ajaxurl, {\n\t                        _nonce: window.taxonomyImport.ajaxNonce,\n\t                        action: 'dfwood_wp_taxonomy_import',\n\t                        taxonomy: taxonomyBase,\n\t                        terms: JSON.stringify(simplifyTerms(termsByParent[parent], parent))\n\t                    }, window.taxonomyImport.ajaxNonce).then(function (response) {\n\t                        response.json().then(function (json) {\n\t                            if (json.terms) {\n\t                                Object.keys(json.terms).map(function (k) {\n\t                                    var id = parseInt(k, 10);\n\t                                    termParentMap[id] = json.terms[k];\n\t                                    if (termsByParent[id] && termsByParent[id].length) {\n\t                                        ajaxInsertTerms(id);\n\t                                    }\n\t                                });\n\t                            }\n\t                        });\n\t                    });\n\t                }\n\t            };\n\t\n\t            /*const insertTerms = (parent = 0) => {\n\t                termsByParent[parent].forEach((term) => {\n\t                    const data = {\n\t                        name: term.name,\n\t                    };\n\t                    if (0 !== parent && 0 < termParentMap[parent]) {\n\t                        data.parent = termParentMap[parent];\n\t                    }\n\t                    POST(`${window.taxonomyImport.restApi}${taxonomyBase}`, data, window.taxonomyImport.restNonce)\n\t                        .then((response) => {\n\t                            response.json().then((json) => {\n\t                                console.log(json);\n\t                                if (json.code && json.code === 'term_exists') {\n\t                                } else {\n\t                                    termParentMap[term.id] = json.id;\n\t                                    if (termsByParent[term.id] && termsByParent[term.id].length) {\n\t                                        insertTerms(term.id);\n\t                                    }\n\t                                }\n\t                            });\n\t                        });\n\t                });\n\t            };*/\n\t\n\t            var requestTerms = function requestTerms(pageNum) {\n\t                url.searchParams.set('page', '' + pageNum);\n\t\n\t                (0, _restApiRequest.GET)(url.toString()).then(function (response) {\n\t                    response.json().then(function (json) {\n\t                        page++;\n\t                        if (200 === response.status) {\n\t                            totalPages = response.headers.get('X-WP-Totalpages');\n\t                        }\n\t                        if (Array.isArray(json)) {\n\t                            console.log(json);\n\t                            json.forEach(function (term) {\n\t                                if (!termsByParent[term.parent]) {\n\t                                    termsByParent[term.parent] = [];\n\t                                }\n\t                                termsByParent[term.parent].push(term);\n\t                            });\n\t                        }\n\t                        if (totalPages >= page) {\n\t                            requestTerms(page);\n\t                        } else {\n\t                            // TODO: Consider re-implementing REST API insertion?\n\t                            // if ('ajax' === method) {\n\t                            ajaxInsertTerms();\n\t                            // } else {\n\t                            //    insertTerms();\n\t                            // }\n\t                        }\n\t                    });\n\t                });\n\t            };\n\t\n\t            requestTerms(page);\n\t        });\n\t    }\n\t});\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t(function(self) {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  var support = {\n\t    searchParams: 'URLSearchParams' in self,\n\t    iterable: 'Symbol' in self && 'iterator' in Symbol,\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob()\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self,\n\t    arrayBuffer: 'ArrayBuffer' in self\n\t  }\n\t\n\t  if (support.arrayBuffer) {\n\t    var viewClasses = [\n\t      '[object Int8Array]',\n\t      '[object Uint8Array]',\n\t      '[object Uint8ClampedArray]',\n\t      '[object Int16Array]',\n\t      '[object Uint16Array]',\n\t      '[object Int32Array]',\n\t      '[object Uint32Array]',\n\t      '[object Float32Array]',\n\t      '[object Float64Array]'\n\t    ]\n\t\n\t    var isDataView = function(obj) {\n\t      return obj && DataView.prototype.isPrototypeOf(obj)\n\t    }\n\t\n\t    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n\t      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n\t    }\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  // Build a destructive iterator for the value list\n\t  function iteratorFor(items) {\n\t    var iterator = {\n\t      next: function() {\n\t        var value = items.shift()\n\t        return {done: value === undefined, value: value}\n\t      }\n\t    }\n\t\n\t    if (support.iterable) {\n\t      iterator[Symbol.iterator] = function() {\n\t        return iterator\n\t      }\n\t    }\n\t\n\t    return iterator\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t    } else if (Array.isArray(headers)) {\n\t      headers.forEach(function(header) {\n\t        this.append(header[0], header[1])\n\t      }, this)\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var oldValue = this.map[name]\n\t    this.map[name] = oldValue ? oldValue+','+value : value\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    name = normalizeName(name)\n\t    return this.has(name) ? this.map[name] : null\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = normalizeValue(value)\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    for (var name in this.map) {\n\t      if (this.map.hasOwnProperty(name)) {\n\t        callback.call(thisArg, this.map[name], name, this)\n\t      }\n\t    }\n\t  }\n\t\n\t  Headers.prototype.keys = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push(name) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.values = function() {\n\t    var items = []\n\t    this.forEach(function(value) { items.push(value) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.entries = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push([name, value]) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  if (support.iterable) {\n\t    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    var promise = fileReaderReady(reader)\n\t    reader.readAsArrayBuffer(blob)\n\t    return promise\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    var promise = fileReaderReady(reader)\n\t    reader.readAsText(blob)\n\t    return promise\n\t  }\n\t\n\t  function readArrayBufferAsText(buf) {\n\t    var view = new Uint8Array(buf)\n\t    var chars = new Array(view.length)\n\t\n\t    for (var i = 0; i < view.length; i++) {\n\t      chars[i] = String.fromCharCode(view[i])\n\t    }\n\t    return chars.join('')\n\t  }\n\t\n\t  function bufferClone(buf) {\n\t    if (buf.slice) {\n\t      return buf.slice(0)\n\t    } else {\n\t      var view = new Uint8Array(buf.byteLength)\n\t      view.set(new Uint8Array(buf))\n\t      return view.buffer\n\t    }\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (!body) {\n\t        this._bodyText = ''\n\t      } else if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t        this._bodyText = body.toString()\n\t      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n\t        this._bodyArrayBuffer = bufferClone(body.buffer)\n\t        // IE 10-11 can't handle a DataView body.\n\t        this._bodyInit = new Blob([this._bodyArrayBuffer])\n\t      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n\t        this._bodyArrayBuffer = bufferClone(body)\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t\n\t      if (!this.headers.get('content-type')) {\n\t        if (typeof body === 'string') {\n\t          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n\t        } else if (this._bodyBlob && this._bodyBlob.type) {\n\t          this.headers.set('content-type', this._bodyBlob.type)\n\t        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n\t        }\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyArrayBuffer) {\n\t          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        if (this._bodyArrayBuffer) {\n\t          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n\t        } else {\n\t          return this.blob().then(readBlobAsArrayBuffer)\n\t        }\n\t      }\n\t    }\n\t\n\t    this.text = function() {\n\t      var rejected = consumed(this)\n\t      if (rejected) {\n\t        return rejected\n\t      }\n\t\n\t      if (this._bodyBlob) {\n\t        return readBlobAsText(this._bodyBlob)\n\t      } else if (this._bodyArrayBuffer) {\n\t        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n\t      } else if (this._bodyFormData) {\n\t        throw new Error('could not read FormData body as text')\n\t      } else {\n\t        return Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t\n\t    if (input instanceof Request) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body && input._bodyInit != null) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = String(input)\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  Request.prototype.clone = function() {\n\t    return new Request(this, { body: this._bodyInit })\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function parseHeaders(rawHeaders) {\n\t    var headers = new Headers()\n\t    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n\t      var parts = line.split(':')\n\t      var key = parts.shift().trim()\n\t      if (key) {\n\t        var value = parts.join(':').trim()\n\t        headers.append(key, value)\n\t      }\n\t    })\n\t    return headers\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this.type = 'default'\n\t    this.status = 'status' in options ? options.status : 200\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n\t    this.headers = new Headers(options.headers)\n\t    this.url = options.url || ''\n\t    this._initBody(bodyInit)\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  Response.prototype.clone = function() {\n\t    return new Response(this._bodyInit, {\n\t      status: this.status,\n\t      statusText: this.statusText,\n\t      headers: new Headers(this.headers),\n\t      url: this.url\n\t    })\n\t  }\n\t\n\t  Response.error = function() {\n\t    var response = new Response(null, {status: 0, statusText: ''})\n\t    response.type = 'error'\n\t    return response\n\t  }\n\t\n\t  var redirectStatuses = [301, 302, 303, 307, 308]\n\t\n\t  Response.redirect = function(url, status) {\n\t    if (redirectStatuses.indexOf(status) === -1) {\n\t      throw new RangeError('Invalid status code')\n\t    }\n\t\n\t    return new Response(null, {status: status, headers: {location: url}})\n\t  }\n\t\n\t  self.Headers = Headers\n\t  self.Request = Request\n\t  self.Response = Response\n\t\n\t  self.fetch = function(input, init) {\n\t    return new Promise(function(resolve, reject) {\n\t      var request = new Request(input, init)\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      xhr.onload = function() {\n\t        var options = {\n\t          status: xhr.status,\n\t          statusText: xhr.statusText,\n\t          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n\t        }\n\t        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.ontimeout = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// assets/js/wp-taxonomy-import.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2b74047cce55f84c00a6","export function ready(fn) {\n    if (document.attachEvent ? document.readyState === 'complete' : document.readyState !== 'loading') {\n        fn();\n    } else {\n        document.addEventListener('DOMContentLoaded', fn);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./source/js/modules/no-jquery/index.js","import 'whatwg-fetch';\n\nfunction doFetch(request) {\n    // Make our fetch request.\n    return fetch(request).then(response => {\n        // Verify returned content type and setup response.\n        const contentType = response.headers.get('content-type');\n        if (contentType && contentType.includes('application/json')) {\n            return response;\n        }\n        // Invalid content received!\n        throw new TypeError(`ERROR: Expected JSON response, received '${contentType}' instead!`);\n    });\n}\n\nexport function GET(url, data = {}, nonce = '') {\n    let query = [];\n    Object.keys(data).map(k => query.push(`${k}=${data[k]}`));\n\n    url += url.includes('?') ? `&${query.join('&')}` : `?${query.join('&')}`;\n\n    const headers = new Headers();\n    if (nonce) {\n        headers.set('X-WP-Nonce', nonce);\n    }\n\n    const request = new Request(url, {\n        credentials: 'same-origin',\n        headers,\n        method: 'GET',\n    });\n\n    return doFetch(request);\n}\n\nexport function POST(url, data = {}, nonce = '') {\n    // Set data as body content\n    const body = new FormData();\n    Object.keys(data).map(k => body.append(k, data[k]));\n\n    // Create request\n    const request = new Request(url, {\n        credentials: 'same-origin',\n        body,\n        headers: new Headers({\n            'X-WP-Nonce': nonce,\n        }),\n        method: 'POST',\n    });\n\n    return doFetch(request);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./source/js/modules/rest-api-request/index.js","import {ready} from 'no-jquery';\nimport {GET, POST} from 'rest-api-request';\n\nready(() => {\n\n    const form = document.querySelector('.taxonomy-import-form');\n\n    if (form) {\n        const importToField = form.querySelector('[name=\"_taxonomy_import_to\"]');\n        const importFromField = form.querySelector('[name=\"_taxonomy_import_rest_url\"]');\n        const button = form.querySelector('button');\n\n        button.addEventListener('click', () => {\n            const taxonomyBase = importToField.value;\n            const remoteRest = importFromField.value;\n            const method = form.querySelector('input[name=\"_taxonomy_import_use_ajax\"]').value === '' ? 'rest' : 'ajax';\n\n            if (!taxonomyBase || !remoteRest) {\n                alert('A required field was left empty!');\n                return;\n            }\n\n            const termsByParent = [];\n            const termParentMap = [];\n            const url = new window.URL(remoteRest);\n            url.searchParams.set('per_page', '100');\n\n            let page = 1;\n            let totalPages = 0;\n\n            const simplifyTerms = (terms, parent) => {\n                const simpleTerms = [];\n                terms.forEach((term) => {\n                    const data = {\n                        id: term.id,\n                        name: term.name,\n                        slug: term.slug,\n                        parent: 0,\n                    };\n                    if (0 < parent && termParentMap[parent]) {\n                        data.parent = termParentMap[parent];\n                    }\n                    simpleTerms.push(data);\n                });\n\n                return simpleTerms;\n            };\n\n            const ajaxInsertTerms = (parent = 0) => {\n                if (termsByParent[parent] && termsByParent[parent].length) {\n                    POST(window.ajaxurl, {\n                        _nonce: window.taxonomyImport.ajaxNonce,\n                        action: 'dfwood_wp_taxonomy_import',\n                        taxonomy: taxonomyBase,\n                        terms: JSON.stringify(simplifyTerms(termsByParent[parent], parent)),\n                    }, window.taxonomyImport.ajaxNonce)\n                        .then((response) => {\n                            response.json().then((json) => {\n                                if (json.terms) {\n                                    Object.keys(json.terms).map((k) => {\n                                        const id = parseInt(k, 10);\n                                        termParentMap[id] = json.terms[k];\n                                        if (termsByParent[id] && termsByParent[id].length) {\n                                            ajaxInsertTerms(id);\n                                        }\n                                    });\n                                }\n                            });\n                        });\n                }\n            };\n\n            /*const insertTerms = (parent = 0) => {\n                termsByParent[parent].forEach((term) => {\n                    const data = {\n                        name: term.name,\n                    };\n                    if (0 !== parent && 0 < termParentMap[parent]) {\n                        data.parent = termParentMap[parent];\n                    }\n                    POST(`${window.taxonomyImport.restApi}${taxonomyBase}`, data, window.taxonomyImport.restNonce)\n                        .then((response) => {\n                            response.json().then((json) => {\n                                console.log(json);\n                                if (json.code && json.code === 'term_exists') {\n                                } else {\n                                    termParentMap[term.id] = json.id;\n                                    if (termsByParent[term.id] && termsByParent[term.id].length) {\n                                        insertTerms(term.id);\n                                    }\n                                }\n                            });\n                        });\n                });\n            };*/\n\n            const requestTerms = (pageNum) => {\n                url.searchParams.set('page', `${pageNum}`);\n\n                GET(url.toString())\n                    .then((response) => {\n                        response.json().then((json) => {\n                            page++;\n                            if (200 === response.status) {\n                                totalPages = response.headers.get('X-WP-Totalpages');\n                            }\n                            if (Array.isArray(json)) {\n                                console.log(json);\n                                json.forEach((term) => {\n                                    if (!termsByParent[term.parent]) {\n                                        termsByParent[term.parent] = [];\n                                    }\n                                    termsByParent[term.parent].push(term);\n                                });\n                            }\n                            if (totalPages >= page) {\n                                requestTerms(page);\n                            } else {\n                                // TODO: Consider re-implementing REST API insertion?\n                                // if ('ajax' === method) {\n                                ajaxInsertTerms();\n                                // } else {\n                                //    insertTerms();\n                                // }\n                            }\n                        });\n                    });\n            };\n\n            requestTerms(page);\n        });\n    }\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./source/js/wp-taxonomy-import.js","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/whatwg-fetch/fetch.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}